% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Kest_anin_cylinder.R
\name{Kest_anin_cylinder}
\alias{Kest_anin_cylinder}
\title{Anisotropic and Inhomogeneous K function, cylinder version}
\usage{
Kest_anin_cylinder(
  x,
  u,
  epsilon,
  r,
  lambda = NULL,
  lambda_h,
  renormalise = TRUE,
  border = 1,
  aspect = 1/3,
  ...
)
}
\arguments{
\item{x}{pp, list with $x~coordinates $bbox~bounding box}

\item{u}{unit vector(s) of direction, as row vectors. Default: x and y axes, viz. c(1,0) and c(0,1).}

\item{epsilon}{The cylinder half-width. Will be extended to the length of r, so can be given per r.}

\item{r}{radius vector at which to evaluate K}

\item{lambda}{optional vector of intensity estimates at points}

\item{lambda_h}{if lambda missing, use this bandwidth in a kernel estimate of lambda(x)}

\item{renormalise}{See details.}

\item{border}{Use border correction? Default=1, yes.}

\item{aspect}{Instead of using a fixed halfwidth (epsilon) take the halfwidth to be 'aspect * r/2' (so an increasing vector). Default : 1/3}

\item{...}{passed on to e.g. \link{intensity_at_points}}
}
\value{
Returns a dataframe.
}
\description{
Estimate a cylinder-K function for second order reweighted ("inhomogeneous") pattern.
}
\details{
Computes a second order reweighted version of the cylinder-K. In short, we count how many pairs of points in the pattern 
has both a) their difference vector inside a cylinder with major-axial direction 'u' and radius epsilon,  and 
b) difference vector length less than range r. Usually r is a vector and the output is then a vector as well.

Note the default behaviour is to use a fixed aspect ratio cylinder with aspect = 2*epsilon/range = 1/3.

An estimate of the intensity Lambda(x) at points can be given ('lambda'). If it is a single value, the pattern is assumed to be homogeneous. 
If it is a vector the same length as there are points, the pattern is taken to be second-order stationary. In this case the 
the sum over the pairs (i,j) is weighted with 1/(lambda[i]*lambda[j]). If 'lambda' is missing, 'lambda_h', a single positive number, 
should be given, which is then used for estimating the non-constant Lambda(x) via Epanechnikov kernel smoothing (see \link{intensity_at_points}).
If 'renormalise=TRUE', we normalise the intensity estimate so that sum(1/lambda(x))=|W|. This corresponds in \code{spatstat}'s \code{Kinhom} to setting 'normpower=2'.

About border correction: If x$bbox is a a simple bounding box, the algorithm uses the translation corrected weighting 1/area(Wx intersect Wy) with Wx=W+x. If x$bbox is a bbquad-object, for example rotated polygon, the algorithm uses simple minus border correction.
}
